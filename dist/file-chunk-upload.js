(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FileUploader"] = factory();
	else
		root["FileUploader"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/utils/AsyncQueue.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AsyncQueue =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {Number} num
   */
  function AsyncQueue(num) {
    _classCallCheck(this, AsyncQueue);

    num = Number(num);
    this.maxLength = num > 0 ? num : 1;
    this.queue = [];
    this.uid = 0;
    this.set = new Set();
    this.map = {};
    this.index = 0;
  }
  /**
   * Add a callback to the queue
   * @param {Function} callback
   * @param {String} taskId
   * @param {Boolean} forward
   * @return {Number}
   */


  _createClass(AsyncQueue, [{
    key: "add",
    value: function add(callback, taskId, forward) {
      var operator = forward ? 'unshift' : 'push';
      var uid = this.uid++; // this.queue[operator]({
      //   uid,
      //   fn: callback,
      //   taskId
      // });
      // this.run();
      // return uid;

      var index = this.queue.findIndex(function (item) {
        return item.taskId === taskId;
      });
      var task;

      if (index === -1) {
        task = {
          taskId: taskId,
          taskList: []
        };
        this.queue.unshift(task);
      } else task = this.queue[index];

      task.taskList[operator]({
        uid: uid,
        fn: callback
      });
      this.run();
      return uid;
    }
    /**
     * Run the callback from the queue
     */

  }, {
    key: "run",
    value: function run() {
      var _this = this;

      Promise.resolve().then(function () {
        var _loop2 = function _loop2() {
          var _this$queue$_this$ind = _this.queue[_this.index],
              taskId = _this$queue$_this$ind.taskId,
              taskList = _this$queue$_this$ind.taskList;

          if (_this.map[taskId]) {
            if (_this.index === 0) return "break";
            _this.index = 0;
            return "continue";
          }

          var _taskList$shift = taskList.shift(),
              uid = _taskList$shift.uid,
              fn = _taskList$shift.fn;

          _this.set.add(uid);

          Promise.resolve().then(function () {
            return fn(uid);
          });
          if (taskList.length === 0) _this.queue.splice(_this.index, 1);else _this.index++;
          if (_this.index >= _this.queue.length) _this.index = 0;
        };

        // for(let i = 0; i < this.queue.length && this.set.size < this.maxLength; i++) {
        //   let { uid, fn, taskId } = this.queue[i];
        //   if(this.map[taskId]) continue;
        //   Promise.resolve().then(() => fn(uid));
        //   this.set.add(uid);
        //   this.queue.splice(i--, 1);
        // }
        _loop: while (_this.index < _this.queue.length && _this.set.size < _this.maxLength) {
          var _ret = _loop2();

          switch (_ret) {
            case "break":
              break _loop;

            case "continue":
              continue;
          }
        }
      });
    }
    /**
     * Notify the queue to complete the task
     * @param {String} uid
     */

  }, {
    key: "done",
    value: function done(uid) {
      if (this.set.has(uid)) {
        this.set.delete(uid);
      }

      this.run();
    }
    /**
     * Change the max length
     * @param {Number} num
     */

  }, {
    key: "changeLength",
    value: function changeLength(num) {
      num = Number(num);
      this.maxLength = num > 0 ? num : 1;
      this.run();
    }
    /**
     * Notify the queue pause the task
     * @param {String} taskId
     */

  }, {
    key: "pause",
    value: function pause(taskId) {
      this.map[taskId] = true;
      var index = this.queue.findIndex(function (item) {
        return item.taskId === taskId;
      });
      if (index === -1) return;
      var task = this.queue[index];
      this.queue.splice(index, 1);
      this.queue.push(task);
    }
    /**
     * Notify the queue continue the task
     * @param {String} taskId
     */

  }, {
    key: "continue",
    value: function _continue(taskId) {
      delete this.map[taskId];
      var index = this.queue.findIndex(function (item) {
        return item.taskId === taskId;
      });
      if (index === -1) return;
      var task = this.queue[index];
      this.queue.splice(index, 1);
      this.queue.unshift(task);
      this.run();
    }
    /**
     * Notify the queue remove the task
     * @param {String} taskId
     */

  }, {
    key: "remove",
    value: function remove(taskId) {
      delete this.map[taskId];

      for (var i = this.queue.length - 1; i >= 0; i--) {
        if (this.queue[i].taskId === taskId) this.queue.splice(i, 1);
      }
    }
  }]);

  return AsyncQueue;
}();

/* harmony default export */ var utils_AsyncQueue = (AsyncQueue);
// EXTERNAL MODULE: ./node_modules/spark-md5/spark-md5.js
var spark_md5 = __webpack_require__(0);
var spark_md5_default = /*#__PURE__*/__webpack_require__.n(spark_md5);

// CONCATENATED MODULE: ./src/utils/Observer.js
function Observer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Observer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Observer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Observer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Observer_defineProperties(Constructor, staticProps); return Constructor; }

var Observer =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function Observer() {
    Observer_classCallCheck(this, Observer);

    this.messages = {};
  }
  /**
   * Get all listeners by type
   * @param {String} type
   * @return {Function[]}
   */


  Observer_createClass(Observer, [{
    key: "getListeners",
    value: function getListeners(type) {
      var messages = this.messages;
      type = type.toLowerCase();
      return messages[type] || (messages[type] = []);
    }
    /**
     * Add a event listener
     * @param {String} type
     * @param {Function} listener
     */

  }, {
    key: "on",
    value: function on(type, listener) {
      var listeners = this.getListeners(type);
      if (listeners.indexOf(listener) === -1) listeners.push(listener);
    }
    /**
     * Add a event listener
     * @param {String} type
     * @param {Function} listener
     */

  }, {
    key: "addListener",
    value: function addListener(type, listener) {
      this.on(type, listener);
    }
    /**
     * Fire event
     * @param {String} type
     */

  }, {
    key: "fireEvent",
    value: function fireEvent(type) {
      var args = Array.prototype.slice.call(arguments, 1),
          listeners = this.getListeners(type);

      for (var fn, j = 0; j < listeners.length; j++) {
        fn = listeners[j];

        if (fn.apply(this, args) === false) {
          return false;
        }

        while (listeners[j] !== fn) {
          j--;
        }
      }

      return true;
    }
    /**
     * Remove a event listener
     * @param {String} type
     * @return {Boolean}
     */

  }, {
    key: "remove",
    value: function remove(type, listener) {
      var listeners = this.getListeners(type),
          index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
        return true;
      }

      return false;
    }
  }]);

  return Observer;
}();

/* harmony default export */ var utils_Observer = (Observer);
// CONCATENATED MODULE: ./src/utils/FileHandler.js
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function FileHandler_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FileHandler_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function FileHandler_createClass(Constructor, protoProps, staticProps) { if (protoProps) FileHandler_defineProperties(Constructor.prototype, protoProps); if (staticProps) FileHandler_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;

var FileHandler_FileHandler =
/*#__PURE__*/
function (_Observer) {
  _inherits(FileHandler, _Observer);

  /**
   * Constructor
   * @param {File} file
   * @param {Number} firstSize
   * @param {Number} chunkSize
   */
  function FileHandler(file, firstSize, chunkSize) {
    var _this;

    FileHandler_classCallCheck(this, FileHandler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FileHandler).call(this));
    _this.file = file;
    _this.size = file.size;
    _this.firstSize = firstSize || 1024 * 256;
    _this.chunkSize = chunkSize || 1024 * 1024 * 4;
    _this.total = Math.ceil(_this.size / _this.chunkSize) || 1;
    _this.stop = false;
    return _this;
  }
  /**
   * Calculate the md5 value of the file
   */


  FileHandler_createClass(FileHandler, [{
    key: "calculate",
    value: function calculate() {
      var _this2 = this;

      var index = 0;
      var size = this.size;
      var chunkSize = this.chunkSize;
      var file = this.file;
      var total = this.total;
      var fileReader = new FileReader();
      var spark = new spark_md5_default.a.ArrayBuffer();
      var chunk, start, end;

      fileReader.onload = function (event) {
        if (_this2.stop) return;
        var chunkSpark = new spark_md5_default.a.ArrayBuffer();
        spark.append(event.target.result);
        chunkSpark.append(event.target.result);
        var md5 = chunkSpark.end();
        index++;
        if (index === total) _this2.fireEvent('load', spark.end());

        _this2.fireEvent('chunkLoad', {
          chunk: chunk,
          md5: md5,
          index: index - 1,
          start: start,
          end: end
        });

        if (index !== total) read();
      };

      fileReader.onerror = function (event) {
        console.warn('oops, something went wrong.');

        _this2.fireEvent('error');
      };

      var read = function read() {
        if (_this2.stop) return;
        start = chunkSize * index;
        end = start + chunkSize >= size ? size : start + chunkSize;
        chunk = blobSlice.call(file, start, end);
        fileReader.readAsArrayBuffer(chunk);
      };

      read();
    }
    /**
     * Calculate the md5 value of the first size of the file
     */

  }, {
    key: "calculateForFirstSize",
    value: function calculateForFirstSize() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var fileReader = new FileReader();
        var spark = new spark_md5_default.a.ArrayBuffer();

        fileReader.onload = function (event) {
          if (_this3.stop) reject();else resolve(spark.end());
        };

        fileReader.onerror = function (event) {
          reject();
        };

        var end = _this3.firstSize >= _this3.size ? _this3.size : _this3.firstSize;
        fileReader.readAsArrayBuffer(blobSlice.call(_this3.file, 0, end));
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this.stop = true;
    }
  }]);

  return FileHandler;
}(utils_Observer);

/* harmony default export */ var utils_FileHandler = (FileHandler_FileHandler);
// CONCATENATED MODULE: ./src/utils/util.js
/**
 * Generate Guid
 * @return {String}
 */
var guid = function guid() {
  var s = [];
  var hexDigits = "0123456789abcdef";

  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  } // bits 12-15 of the time_hi_and_version field to 0010


  s[14] = "4"; // bits 6-7 of the clock_seq_hi_and_reserved to 01

  s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1);
  s[8] = s[13] = s[18] = s[23] = "-";
  return s.join("");
};
/**
 * Use Object.prototype.toString
 * @param {Any} obj
 * @return {String}
 */

var util_toString = function toString(obj) {
  return Object.prototype.toString.call(obj);
};
/**
 * Check whether the fn is function
 * @param {Any} fn
 * @return {Boolean}
 */

var isFunction = function isFunction(fn) {
  return util_toString(fn) === '[object Function]';
};
/**
 * Check whether the obj is Object
 * @param {Any} obj
 * @return {Boolean}
 */

var isObject = function isObject(obj) {
  return util_toString(obj) === '[object Object]';
};
/**
 * Check whether the p is Promise
 * @param {Any} p
 * @return {Boolean}
 */

var isPromise = function isPromise(p) {
  if (util_toString(p) === '[object Promise]') return true;
  return !!p && isFunction(p.then) && isFunction(p.cacah) && isFunction(p.finally);
};
/**
 * Extend the object
 * @param {Object} target
 * @param {Object} source
 * @return {Object}
 */

var extend = function extend(target, options) {
  target = target || {};
  options = options || {};

  for (var key in options) {
    var value1 = target[key];
    var value2 = options[key];

    if (Array.isArray(value2)) {
      target[key] = extend(value1 || [], value2);
    } else if (isObject(value2)) {
      target[key] = extend(value1 || {}, value2);
    } else if (util_toString(value1) === util_toString(value2)) {
      target[key] = value1;
    } else {
      target[key] = value2;
    }
  }

  return target;
};
// CONCATENATED MODULE: ./src/utils/request.js

/**
 * Creates a XHR request
 * @param {Object} options
 * @return {XMLHttpRequest}
 */

var createRequest = function createRequest(options) {
  var xhr = new XMLHttpRequest();
  xhr.open(options.type || 'GET', options.url, true);
  xhr.responseType = options.responseType || 'json';

  if (options.headers) {
    Object.keys(options.headers).forEach(function (key) {
      xhr.setRequestHeader(key, options.headers[key]);
    });
  }

  xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  return xhr;
};
/**
 * Send a XHR request
 * @param {XMLHttpRequest} xhr
 * @return {Promise}
 */


var sendRequest = function sendRequest(xhr, data) {
  var promise = new Promise(function (resolve, reject) {
    xhr.onload = function () {
      if (xhr.status >= 200 && xhr.status < 300) {
        var response;

        try {
          response = JSON.parse(xhr.response);
        } catch (err) {
          response = xhr.response;
        }

        resolve(response);
      } else {
        reject(xhr);
      }
    };

    xhr.onerror = function (err) {
      return reject(xhr);
    };

    xhr.onabort = function () {
      return reject('abort');
    };

    xhr.send(data);
  });

  promise.abort = function () {
    xhr.abort();
  };

  return promise;
};
/**
 * Submit file with XHR
 * @param {Object} options
 * @return {Promise}
 */


var request_submitFile = function submitFile(options) {
  options = extend({}, options);
  var data = options.data;
  var formData = new FormData();

  for (var name in data) {
    formData.append(name, data[name]);
  }

  options.type = options.type || 'POST';
  options.headers = options.headers || {}; // options.headers['Content-type'] = 'multipart/form-data;charset=utf-8';

  var xhr = createRequest(options);

  if (typeof options.progress === 'function') {
    xhr.upload.addEventListener('progress', function (evt) {
      if (evt.lengthComputable) {
        options.progress(evt);
      }
    }, false);
  }

  return sendRequest(xhr, formData);
};
/**
 * Send a normal request
 * @param {Object} options
 * @returns Promise
 */

/* harmony default export */ var request = (function (options) {
  options = extend({}, options);
  options.type = (options.type || 'GET').toUpperCase();
  var data,
      url = options.url;

  if (options.data) {
    data = '';
    Object.keys(options.data).forEach(function (key) {
      if (options.data[key] === undefined) return;
      if (data) data += "&";
      data += "".concat(key, "=").concat(options.data[key]);
    });
  }

  if (options.type === 'GET' && data) {
    options.url += "?".concat(data);
    data = null;
  }

  if (options.type === 'POST') {
    var headers = options.headers || {};

    if (options.contentType === 'json') {
      headers['Content-type'] = 'application/json;charset=utf-8';
      data = JSON.stringify(options.data);
    } else if (data) {
      headers['Content-type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    }

    options.headers = headers;
  }

  return sendRequest(createRequest(options), data);
});
// CONCATENATED MODULE: ./src/utils/Uploader.js
function Uploader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Uploader_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Uploader_createClass(Constructor, protoProps, staticProps) { if (protoProps) Uploader_defineProperties(Constructor.prototype, protoProps); if (staticProps) Uploader_defineProperties(Constructor, staticProps); return Constructor; }




var PREPARE = 0;
var UPLOADING = 1;
var PAUSE = 2;
var COMPLETED = 3;
var ERROR = 4;
var ABORT = 5;
var chunkObject = {
  md5: '',
  uploadSize: 0,
  uploadPromise: null,
  done: false
};
/**
 * Prepare for upload to get uploadId
 * @param {Object} parameters
 * @return {Promise}
 */

var Uploader_prepare = function prepare(fileObj, _ref) {
  var uploadId = _ref.uploadId,
      url = _ref.url,
      headers = _ref.headers,
      file = _ref.file;
  return request({
    url: url,
    headers: headers,
    data: {
      uploadId: uploadId,
      fileName: file.name,
      size: file.size
    }
  });
};
/**
 * Upload chunk file
 *
 * @param {Object} fileObj
 * @param {Object} parameters
 * @param {Function} onProgress
 * @return {Promise}
 */


var Uploader_upload = function upload(fileObj, _ref2, onProgress) {
  var uploadId = _ref2.uploadId,
      url = _ref2.url,
      headers = _ref2.headers,
      chunk = _ref2.chunk,
      md5 = _ref2.md5,
      index = _ref2.index,
      start = _ref2.start,
      end = _ref2.end;
  return request_submitFile({
    url: url,
    headers: headers,
    data: {
      uploadId: uploadId,
      md5: md5,
      index: index,
      start: start,
      end: end,
      file: chunk
    },
    progress: function progress(evt) {
      var percent = evt.loaded / evt.total;
      onProgress(percent);
    }
  });
};
/**
 * Check md5
 *
 * @param {Object} fileObj
 * @param {Object} parameters
 * @return {Promise}
 */


var _checkMD = function checkMD5(fileObj, _ref3) {
  var uploadId = _ref3.uploadId,
      url = _ref3.url,
      headers = _ref3.headers,
      md5 = _ref3.md5,
      file = _ref3.file;
  return request({
    url: url,
    headers: headers,
    data: {
      uploadId: uploadId,
      md5: md5,
      fileName: file.name
    }
  });
};
/**
 * Merge chunk to file
 *
 * @param {Object} fileObj
 * @param {Object} parameters
 * @return {Promise}
 */


var _merge = function merge(fileObj, _ref4) {
  var uploadId = _ref4.uploadId,
      url = _ref4.url,
      headers = _ref4.headers,
      md5 = _ref4.md5,
      chunkMD5List = _ref4.chunkMD5List,
      file = _ref4.file;
  return request({
    url: url,
    type: 'post',
    contentType: 'json',
    headers: headers,
    data: {
      uploadId: uploadId,
      md5: md5,
      chunkMD5List: chunkMD5List,
      fileName: file.name
    }
  });
};

var Uploader_Uploader =
/*#__PURE__*/
function () {
  /**
   * Constructor
   *
   * @param {File} file
   * @param {Object} options
   * @param {AsyncQueue} queue
   * @param {Storage} storage
   */
  function Uploader(file, options, queue, storage) {
    Uploader_classCallCheck(this, Uploader);

    this.initFile(file);
    this.options = options;
    this.queue = queue;
    this.storage = storage;
    if (options.autoUpload) this.upload();
  }
  /**
   * Initialize file data
   *
   * @param {File} file
   */


  Uploader_createClass(Uploader, [{
    key: "initFile",
    value: function initFile(file) {
      this.state = PREPARE;
      this.uploadId = '';
      this.md5 = '';
      this.firstMD5 = '';
      this.taskId = guid();
      this.chunkList = [];
      this.isExistMap = {};
      this.response = null;
      var fileObj = {};
      fileObj.raw = file;
      fileObj.name = file.name;
      fileObj.ext = /\.([^.]+)$/.exec(file.name) ? RegExp.$1.toLowerCase() : '';
      fileObj.size = file.size || 0;
      fileObj.lastModified = file.lastModified;
      fileObj.percentage = 0;
      fileObj.uid = this.taskId;
      this.file = fileObj;
    }
  }, {
    key: "upload",

    /**
     * Prepare for upload
     */
    value: function upload() {
      if (this.state !== PREPARE) return;
      this.state = UPLOADING;
      this.prepare();
    }
    /**
     * Prepare for upload
     */

  }, {
    key: "prepare",
    value: function prepare() {
      var _this = this;

      var _this$options = this.options,
          firstSize = _this$options.firstSize,
          chunkSize = _this$options.chunkSize,
          reupload = _this$options.reupload;
      var fileHandler = new utils_FileHandler(this.file.raw, firstSize, chunkSize);
      this.fileHandler = fileHandler;
      this.chunkList = new Array(fileHandler.total).fill().map(function () {
        return extend({
          reupload: reupload
        }, chunkObject);
      });

      if (fileHandler.total > 1) {
        fileHandler.calculateForFirstSize().then(function (md5) {
          _this.firstMD5 = md5;

          var info = _this.storage.get(_this.getKey());

          if (info && info.done) {
            _this.uploadId = info.uploadId;

            _this.completed(info.response);

            return;
          }

          if (info && info.isUploading) {
            _this.handleError(undefined, 'repetitive');

            return;
          }

          _this.applyForUploadId(info && info.uploadId);
        }).catch(function () {});
      } else {
        this.applyForUploadId();
      }
    }
    /**
     * Apply for uploadId
     * 
     * @param {String} uploadId
     */

  }, {
    key: "applyForUploadId",
    value: function applyForUploadId(uploadId) {
      var _this2 = this;

      var _this$options2 = this.options,
          prepareUrl = _this$options2.prepareUrl,
          headers = _this$options2.headers,
          onPrepare = _this$options2.onPrepare,
          handlePrepare = _this$options2.handlePrepare;
      var param = {
        url: prepareUrl,
        headers: headers,
        file: this.file.raw
      };
      if (uploadId) param.uploadId = uploadId;
      var promise = this.handlePromise(Uploader_prepare, onPrepare, handlePrepare, [param]);
      promise.then(function (_ref5) {
        var uploadId = _ref5.uploadId,
            chunkMD5List = _ref5.chunkMD5List;
        _this2.uploadId = uploadId;
        (chunkMD5List || []).forEach(function (md5) {
          return _this2.isExistMap[md5] = true;
        });

        _this2.calculateMD5();
      }).catch(function (err) {
        _this2.handleError(err, 'prepare');
      });
    }
    /**
     * calculate md5 of the file
     * 
     * @param {String} uploadId
     */

  }, {
    key: "calculateMD5",
    value: function calculateMD5() {
      var _this3 = this;

      var fileHandler = this.fileHandler;
      fileHandler.on('chunkLoad', function (data) {
        var md5 = data.md5,
            index = data.index,
            start = data.start,
            end = data.end;
        _this3.chunkList[index].md5 = md5;

        if ([UPLOADING, PAUSE].indexOf(_this3.state) === -1) {
          fileHandler.abort();
          return;
        }

        if (_this3.isExistMap[md5]) {
          _this3.chunkComleted(index, end - start);

          return;
        }

        _this3.addToQueue(data);
      });
      fileHandler.on('load', function (md5) {
        _this3.checkMD5(md5);
      });
      fileHandler.calculate();
    }
    /**
     * Add chunk upload task to the async queue
     * 
     * @param {Object} data
     * @param {Boolean} forward
     */

  }, {
    key: "addToQueue",
    value: function addToQueue(data, forward) {
      var _this4 = this;

      this.queue.add(function (uid) {
        _this4.uploadChunk(uid, data);
      }, this.taskId, forward);
    }
    /**
     * Upload chunk file
     * 
     * @param {String} uid
     * @param {Object} data
     */

  }, {
    key: "uploadChunk",
    value: function uploadChunk(uid, data) {
      var _this5 = this;

      if ([UPLOADING, PAUSE].indexOf(this.state) === -1) {
        this.queue.done(uid);
        return;
      }

      var chunk = data.chunk,
          md5 = data.md5,
          index = data.index,
          start = data.start,
          end = data.end;
      var _this$options3 = this.options,
          uploadUrl = _this$options3.uploadUrl,
          headers = _this$options3.headers,
          onUpload = _this$options3.onUpload,
          handleUpload = _this$options3.handleUpload;
      var param = {
        uploadId: this.uploadId,
        url: uploadUrl,
        headers: headers,
        chunk: chunk,
        md5: md5,
        index: index,
        start: start,
        end: end
      };

      var onProgress = function onProgress(percent) {
        _this5.chunkList[index].uploadSize = percent * (end - start);
        if ([UPLOADING].indexOf(_this5.state) === -1) return;

        _this5.updatePercentage();
      };

      var promise = this.handlePromise(Uploader_upload, onUpload, handleUpload, [param, onProgress]);
      this.chunkList[index].uploadPromise = promise;
      promise.then(function () {
        _this5.chunkComleted(index, end - start);
      }).catch(function (err) {
        if (err === 'abort') return;

        if (_this5.chunkList[index].reupload > 0) {
          _this5.chunkList[index].reupload--;

          _this5.addToQueue(data, true);
        } else {
          _this5.handleError(err, 'upload');
        }
      }).finally(function () {
        _this5.queue.done(uid);

        _this5.chunkList[index].uploadPromise = null;
      });
    }
    /**
     * Chunk upload completed
     * 
     * @param {Number} index
     * @param {Number} size
     */

  }, {
    key: "chunkComleted",
    value: function chunkComleted(index, size) {
      if (!this.chunkList[index]) return;
      this.chunkList[index].uploadSize = size;
      this.chunkList[index].done = true;
      if ([UPLOADING].indexOf(this.state) === -1) return;
      this.updatePercentage();
      this.saveInfo();
      this.merge();
    }
    /**
     * Check file exists by md5
     * 
     * @param {String} md5
     */

  }, {
    key: "checkMD5",
    value: function checkMD5(md5) {
      var _this6 = this;

      this.md5 = md5;
      var _this$options4 = this.options,
          checkUrl = _this$options4.checkUrl,
          headers = _this$options4.headers,
          onCheck = _this$options4.onCheck,
          handleCheck = _this$options4.handleCheck;
      var param = {
        uploadId: this.uploadId,
        url: checkUrl,
        headers: headers,
        md5: this.md5,
        file: this.file.raw
      };
      var total = this.fileHandler.total;
      if (total === 1) this.queue.pause(this.taskId);
      var promise = this.handlePromise(_checkMD, onCheck, handleCheck, [param]);
      promise.then(function (data) {
        if (data) _this6.completed(data);
      }).catch(function (err) {
        console.log(err);
      }).finally(function () {
        if ([UPLOADING].indexOf(_this6.state) > -1 && total === 1) {
          _this6.queue.continue(_this6.taskId);
        }
      });
    }
    /**
     * Merge chunk to file
     */

  }, {
    key: "merge",
    value: function merge() {
      var _this7 = this;

      if ([UPLOADING, PAUSE].indexOf(this.state) === -1) return;
      if (this.chunkList.some(function (item) {
        return !item.done;
      })) return;
      var _this$options5 = this.options,
          mergeUrl = _this$options5.mergeUrl,
          headers = _this$options5.headers,
          onMerge = _this$options5.onMerge,
          handleMerge = _this$options5.handleMerge;
      var param = {
        uploadId: this.uploadId,
        url: mergeUrl,
        headers: headers,
        md5: this.md5,
        chunkMD5List: this.chunkList.map(function (item) {
          return item.md5;
        }),
        file: this.file.raw
      };
      var promise = this.handlePromise(_merge, onMerge, handleMerge, [param]);
      promise.then(function (data) {
        _this7.completed(data);
      }).catch(function (err) {
        _this7.handleError(err, 'merge');
      });
    }
    /**
     * Upload completed
     *
     * @param {Object} response
     */

  }, {
    key: "completed",
    value: function completed(response) {
      this.response = response;
      this.file.response = response;
      if (this.state !== UPLOADING) return;
      this.state = COMPLETED;
      this.updatePercentage(100);
      this.saveInfo();
      this.remove();

      if (isFunction(this.options.success)) {
        this.options.success.call(this.file, this.file, response);
      }
    }
    /**
     * Handle error
     * @param {Any} err
     */

  }, {
    key: "handleError",
    value: function handleError(err, type) {
      this.state = ERROR;
      this.remove();

      if (isFunction(this.options.error)) {
        this.options.error.call(this.file, this.file, err, type);
      }
    }
    /**
     * Handle promise
     * @param {Function} defaultFn
     * @param {Function} fn
     * @param {Function} callback
     * @param {Array} args
     * @param {Promise}
     */

  }, {
    key: "handlePromise",
    value: function handlePromise(defaultFn, fn, callback, args) {
      var promise;
      args = [this.file].concat(args);

      if (isFunction(fn)) {
        promise = fn.apply(this.file, args);
      }

      if (!promise || !isPromise(promise)) {
        promise = defaultFn.apply(this.file, args);
      }

      promise.then(function (data) {
        var result = data;
        if (isFunction(callback)) result = callback(data);
        return result === undefined ? data : result;
      }).catch(function () {});
      return promise;
    }
    /**
     * Pause upload
     */

  }, {
    key: "pause",
    value: function pause() {
      if (this.state !== UPLOADING) return;
      this.state = PAUSE;
      this.queue.pause(this.taskId);
    }
    /**
     * Continue upload
     */

  }, {
    key: "continue",
    value: function _continue() {
      if (this.state !== PAUSE) return;
      this.state = UPLOADING;

      if (this.response !== null) {
        this.completed(this.response);
        return;
      }

      this.queue.continue(this.taskId);
      this.updatePercentage();
      this.merge();
    }
    /**
     * Stop and remove upload
     */

  }, {
    key: "remove",
    value: function remove() {
      if (this.state !== COMPLETED) this.state = ABORT;
      this.queue.remove(this.taskId);
      this.chunkList.forEach(function (item) {
        if (item.uploadPromise && item.uploadPromise.abort) item.uploadPromise.abort();
      });
      this.fileHandler.abort();
    }
    /**
     * Update the upload percentage
     *
     * @param {Number} number
     */

  }, {
    key: "updatePercentage",
    value: function updatePercentage(number) {
      var percentage;

      if (number) {
        percentage = number;
      } else if (this.file.size) {
        percentage = Math.ceil(this.chunkList.reduce(function (sum, item) {
          return sum + item.uploadSize;
        }, 0) / this.file.size * 100);
      } else {
        percentage = 100;
      }

      if (percentage > 100) {
        percentage = 100;
      }

      this.file.percentage = percentage;
      if (isFunction(this.options.progress)) this.options.progress.call(this.file, this.file);
    }
    /**
     * Get the storage key
     */

  }, {
    key: "getKey",
    value: function getKey() {
      var file = this.file;
      return "".concat(file.name, "#").concat(file.size, "#").concat(file.lastModified, "#").concat(this.firstMD5);
    }
    /**
     * Save the info to storage
     */

  }, {
    key: "saveInfo",
    value: function saveInfo() {
      var key = this.getKey();
      var info = {
        uploadId: this.uploadId
      };

      if (this.state === COMPLETED) {
        info.done = true;
        info.response = this.response;
      } else {
        info.isUploading = true;
      }

      this.storage.set(key, info, this.options.expiration);
    }
  }]);

  return Uploader;
}();

/* harmony default export */ var utils_Uploader = (Uploader_Uploader);
// CONCATENATED MODULE: ./src/utils/Storage.js
function Storage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Storage_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Storage_createClass(Constructor, protoProps, staticProps) { if (protoProps) Storage_defineProperties(Constructor.prototype, protoProps); if (staticProps) Storage_defineProperties(Constructor, staticProps); return Constructor; }

var Storage =
/*#__PURE__*/
function () {
  /**
   * Init then name of localStorage
   *
   * @param {String} name
   */
  function Storage(name) {
    var _this = this;

    Storage_classCallCheck(this, Storage);

    var storage;

    try {
      storage = JSON.parse(localStorage.getItem(name)) || {};
    } catch (e) {
      storage = {};
    }

    this.name = name;
    this.storage = storage;
    Object.keys(this.storage).forEach(function (key) {
      var time = _this.storage[key].time;
      if (time && time < new Date().getTime()) _this.remove(key);
    });
  }
  /**
   * Get the value by key
   * If time is overtime reutrn null
   *
   * @param {String} key
   */


  Storage_createClass(Storage, [{
    key: "get",
    value: function get(key) {
      if (!this.storage[key]) return null;
      var _this$storage$key = this.storage[key],
          time = _this$storage$key.time,
          value = _this$storage$key.value;

      if (time && time < new Date().getTime()) {
        this.remove(key);
        return null;
      }

      return value;
    }
    /**
     * Get the value by key
     * If time is overtime reutrn null
     *
     * @param {String} key
     * @param {Any} value
     * @param {Number} expiration
     */

  }, {
    key: "set",
    value: function set(key, value, expiration) {
      this.storage[key] = {
        time: expiration ? new Date().getTime() + expiration * 1000 : 0,
        value: value
      };
      this.saveToStorage();
    }
    /**
     * Remove the value by key
     *
     * @param {String} key
     */

  }, {
    key: "remove",
    value: function remove(key) {
      delete this.storage[key];
      this.saveToStorage();
    }
    /**
     * Save all value to localStorage
     */

  }, {
    key: "saveToStorage",
    value: function saveToStorage() {
      try {
        localStorage.setItem(this.name, JSON.stringify(this.storage));
      } catch (e) {}
    }
  }]);

  return Storage;
}();

/* harmony default export */ var utils_Storage = (Storage);
// CONCATENATED MODULE: ./src/FileUploader.js
function FileUploader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FileUploader_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function FileUploader_createClass(Constructor, protoProps, staticProps) { if (protoProps) FileUploader_defineProperties(Constructor.prototype, protoProps); if (staticProps) FileUploader_defineProperties(Constructor, staticProps); return Constructor; }





var defaultOptions = {
  // The first size of a file(in B) to breakpoint resume
  firstSize: 256 * 1024,
  // The size of a chunk(in B)
  chunkSize: 4 * 1024 * 1024,
  // The time of expiration
  expiration: 24 * 60 * 60,
  // Number of concurrent uploads
  maxConcurrent: 2,
  // Auto file upload
  autoUpload: true,
  // The url of prepare to upload
  prepareUrl: '/file/prepare',
  // The url of uploading every chunk
  uploadUrl: '/file/upload',
  // The url of checking md5
  checkUrl: '/file/check',
  // The url of merging file
  mergeUrl: '/file/merge',
  // The request headers
  headers: {},
  // The number of reupload the chunk if fail
  reupload: 5
};

var FileUploader_FileUploader =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {Object} options
   */
  function FileUploader(options) {
    var _this = this;

    FileUploader_classCallCheck(this, FileUploader);

    this.options = extend(options, defaultOptions);
    this.queue = new utils_AsyncQueue(options.maxConcurrent);
    this.storage = new utils_Storage('file-upload');
    this.fileList = [];
    this.map = {}; // remove the isUploading state

    Object.keys(this.storage.storage).forEach(function (key) {
      var info = _this.storage.get(key);

      if (info && info.isUploading) {
        info.isUploading = false;
      }
    });
    var methods = ['upload', 'pause', 'continue'];
    methods.forEach(function (method) {
      _this[method] = function (fileObj) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _this.fileList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var file = _step.value;

            if (file === fileObj || file.uid === fileObj) {
              _this.map[file.uid][method]();

              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      _this[method + 'All'] = function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _this.fileList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var file = _step2.value;

            _this.map[file.uid][method]();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      };
    });
  }
  /**
   * Add a file
   * @param {File} file
   * @param {Function} success
   * @param {Function} error
   * @param {Function} progress
   * @return {Object}
   */


  FileUploader_createClass(FileUploader, [{
    key: "addFile",
    value: function addFile(file, success, error, progress) {
      var options = extend({
        success: success,
        error: error,
        progress: progress
      }, this.options);
      var uploader = new utils_Uploader(file, options, this.queue, this.storage);
      this.fileList.push(uploader.file);
      this.map[uploader.file.uid] = uploader;
      return uploader.file;
    }
    /**
     * Remove file
     * @param {Object|String} fileObj
     */

  }, {
    key: "remove",
    value: function remove(fileObj) {
      for (var i in this.fileList) {
        if (this.fileList[i] === fileObj || this.fileList[i].uid === fileObj) {
          this.map[this.fileList[i].uid].remove();
          delete this.map[this.fileList[i].uid];
          this.fileList.splice(i, 1);
          break;
        }
      }
    }
    /**
     * Remove all file
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.fileList[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var file = _step3.value;
          this.map[file.uid].remove();
          delete this.map[file.uid];
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.fileList = [];
    }
  }]);

  return FileUploader;
}();

/* harmony default export */ var src_FileUploader = __webpack_exports__["default"] = (FileUploader_FileUploader);

/***/ })
/******/ ])["default"];
});